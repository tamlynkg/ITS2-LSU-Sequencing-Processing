---
---
title: "Processing Truncated ITS Data . merging replicates"
author: "Tamlyn Gangiah"
output: html_document
date: "2024-03-13"
editor_options: 
  markdown: 
    wrap: 72
---

## Ã„tnarova O-layer Data Upload

-   Load in clusters that have been manually assigned for ECM + SCATA
    assigned clusters
-   Load in tag names and counts data from scata
-   Select rows of only samples sequenced

```{r cars}
#setwd("//storage.slu.se/Home$/tyga0001/Desktop/ITS Sequencing/Tesing 98.5 Truncated")
#\\storage.slu.se\Home$\tyga0001\Desktop\ITS Sequencing\Tesing 98.5 Truncated

library(ggplot2)
library(dplyr)
library(tidyr)

#old assingments from previous analyses
#ECM.assigned <- read.delim("assigned-unknowns.txt", header = TRUE)
#scata.assignments <- read.delim("scata985clustertaxa.txt")

labels.file <- "tagnames-Atnarova-test.txt"
counts.file <- "all_tag_by_cluster_counts.txt"

counts.data.all <- read.delim(counts.file, header = TRUE, sep = ";")
labels <- read.delim(labels.file)
selected_labels <- labels$Tag

counts.data <- counts.data.all[counts.data.all$Tag %in% selected_labels, ] # Select rows with specified labels
```

- Remove columns with zero values for:O-layer and mineral soil
- Add sample labels

```{r}
filtered.counts.data <- counts.data[,-1]
filtered.counts.data <- filtered.counts.data[, colSums(filtered.counts.data) != 0]
filtered.counts.data$Sample <- labels$Sample
filtered.counts.data$Sample <- trimws(filtered.counts.data$Sample)
```

- Create fungal-only counts matrix for O-layer and mineral soil - remove non-fungal clusters
- Only applicable if blasting against SI database 

```{r}
rows.NF <- grepl("NF_", scata.assignments$Reference)
grab.rows.NF <- scata.assignments[rows.NF, ]
NF.to.remove <- grab.rows.NF$Cluster.ID
counts.fungal <- filtered.counts.data[, !names(filtered.counts.data) %in% NF.to.remove]
setdiff(exact_matches, names(counts.ECM))
```

Merge rows into one for technical replicates - for O-layer samples

```{r}
filtered.counts.data$Sample <- substr(filtered.counts.data$Sample, 1, 3)
filtered.counts.data <- aggregate(. ~ Sample, filtered.counts.data, FUN = sum)
#if matching its to long sequences
ecm.its.long <- filtered.counts.data[names(filtered.counts.data) %in% result_df2$sseqid]
ecm.its.long2 <- ecm.its.long %>% select(-scata6384_43)
result_df$scata6387 <- gsub("^([^_]*_[^_]*)_.*", "\\1", result_df$qseqid)
matching_sequences <- ecm.its.long[!exact_sequences %in%names(ecm.its.long)]
```

- Calculating sequencing depth: O-layer and mineral - calculate average
- sequencing depth - check minimum sequencing depth

```{r}
#if it has a low ecm
counts.fungal.filter <- counts.fungal[!(counts.fungal$Sample %in% c("S2(", "S16", "S18")),]
sample.totals <- rowSums(counts.fungal.filter[,-1]) #-1 if merged technical reps


#make a dataframe
sample.seqdepth <- as.data.frame(sample.totals)
sample.seqdepth$Sample <- counts.fungal.filter$Sample
#minimum sequencing depth
min(sample.seqdepth$sample.totals)
mean.seqdepth <- mean(sample.totals)


#Plot histogram of sequencing depth
par(mfrow=c(1,2))  # Arrange plots in a 1x2 layout
hist(sample.seqdepth$sample.totals, col="lightblue", main="O-layer: Depth", xlab="Depth")
```

Create ecm counts matrix for: O-layer and mineral soil

```{r, echo=FALSE}
#only if using previously assinged ITS
non.ecm.cols <- setdiff(names(counts.fungal.filter), ECM.assigned$qseqid)
ecm.counts <- counts.fungal.filter[, !names(counts.fungal.filter) %in% non.ecm.cols]

#Remove zero rows  - added this in the beginning step so not necessary

#ecm.counts.numeric <- sapply(ecm.counts, is.numeric) 
#ecm.counts <- ecm.counts[, ecm.counts.numeric]


#ecm.counts.mineral.numeric <- sapply(ecm.counts.mineral, is.numeric) 
#ecm.counts.mineral <- ecm.counts.mineral[, ecm.counts.mineral.numeric]

sample.totals.ecm <- rowSums(ecm.its.long) #-1 if merged technical reps
mean.seqdepth.ecm <- mean(sample.totals.ecm)

#make dataframe
sample.seqdepth.ecm <- as.data.frame(sample.totals.ecm)
sample.seqdepth.ecm$Sample <- counts.fungal.filter$Sample

#minium sequencing depth for ecm
min(sample.seqdepth.ecm$sample.totals.ecm)

#Plot histogram of sequencing depth
hist(sample.seqdepth.ecm$sample.totals.ecm, col="lightblue", main="O-layer: Depth", xlab="Depth")
```

Calculate species richness - Calculate the number of species present by looking at non-zero values - Calculate adjusted sequencing depth

```{r pressure, echo=FALSE}
species.present <- rowSums(ecm.counts != 0) #number of species that don't have a zero count

#make dataframe
species.present.df <- as.data.frame(species.present)
species.present.df$sample.totals <- sample.totals #sequencing depth

#plotting species richness against sequencing depth
ggplot(species.present.df, aes(x = sample.totals, y = species.present, color = "blue")) +
  geom_bar(stat = "identity") +
  geom_smooth(method = "lm", se = FALSE) +  # Adds the line of best fit
  labs(title = "species present per sequencing depth", x = "Sequencing Depth", y = "Species present") +
  theme_bw() 

species.present.df$species.richness.adj <- with(species.present.df, species.present / sqrt(sample.totals) * sqrt(mean.seqdepth))

#plot against tree density
metadata <- read.delim("metadata.txt", header = TRUE)
#if removing samples with a low count
metadata<- metadata[!(metadata$Sample %in% c("S2", "S16", "S18")),]
species.present.df$Density <- metadata$Density
species.present.df$Sample <- metadata$Sample
species.present.df1<- species.present.df[!(species.present.df$Sample %in% c("S2", "S16", "S18")),]

#Sample richness vs tree density
ggplot(species.present.df1, aes(x = Density, y = species.richness.adj)) +
  geom_point(aes(alpha = 5)) +  # Adjust point transparency with 'alpha'
  geom_smooth(method = "lm", se = FALSE) +  # Adds the line of best fit
  labs(title = "Sample Richness vs Density",  # Add a title 
       x = "Tree Density",
       y = "Sample Richness")
```

Calculate the proportion of ECM
```{r pressure, echo=FALSE}

ecm.sample.total <- rowSums(ecm.counts)

#make dataframe
ecm.sample.total.df <- as.data.frame(ecm.sample.total)
ecm.sample.total.df$Sample <- species.present.df1$Sample

ecm.species.total <- colSums(ecm.counts)
ecm.total <- sum(ecm.counts)

ecm.species.intotal <- ecm.species.total/ecm.total
```

```{r pressure, echo=FALSE}
ecm.proportion.sample <- ecm.sample.total / sample.totals  # Might need adjustment for zero sample_totals1
ecm.proportion.sample*100

ECM.proportion.sample.df <- data.frame(Sample = metadata$Sample,
                        ECMproportion = ecm.proportion.sample)

ECM.proportion.sample.df$Sample <- gsub("\\(|\\)", "", ECM.proportion.sample.df$Sample)
ECM.proportion.sample.df <- merge(ECM.proportion.sample.df, metadata, by = "Sample")

ECM.proportion.sample.df1<- ECM.proportion.sample.df[!(ECM.proportion.sample.df$Sample %in% c("S2", "S16", "S18")),]

library(ggplot2)
ggplot(ECM.proportion.sample.df1, aes(x = Sample, y = ECMproportion, fill = Density)) +
 geom_bar(stat = "identity") +
 labs(title = "ECM Proportion per Sample with SD", x = "Sample", y = "ECM Proportion") +
 theme_bw() 

# Create the scatter plot
ggplot(ECM.proportion.sample.df1, aes(x = ECMproportion, y = Density)) +
 geom_point(aes(alpha = 5)) +  # Adjust point transparency with 'alpha'
 geom_smooth(method = "lm", se = FALSE) +  # Adds the line of best fit
 labs(title = "Sample ECM Proportion vs Density",  # Add a title 
      x = "Density",
      y = "ECM Proportion")


#collapsed.df.ecm <- ECM.proportion.sample.df %>%
#  group_by(Treatment) %>%
#  summarise(across(-OriginalSample, mean))

#collapsed.df.ecm.richness <- species.present.df %>%
#  group_by(Treatment) %>%
#  summarise(across(-Sample, mean))
```

assign scata cluster name to  species name 
add reads for clusters with same species
only necessary if blasting against SI

```{r pressure, echo=FALSE}

matches <- match(names(ecm.counts), ECM.assigned$qseqid)
ECM.species.names <- ECM.assigned$sseqid[matches]
names(ecm.counts) <- ifelse(is.na(matches), ECM.assigned$qseqid, ECM.species.names)

names(ecm.counts) <- sub("SI\\d+[-_]?", "", names(ecm.counts))
names(ecm.counts)<- gsub("^[0-9_]+", "", names(ecm.counts))
names(ecm.counts) <- sub("_ECM", "", names(ecm.counts))
names(ecm.counts)  <- gsub("_", " ", names(ecm.counts))

#edit species name
colnames(ecm.counts)[which(colnames(ecm.counts) == "Cortinarius sp. ")] <- "Cortinarius sp." 
colnames(ecm.counts)[which(colnames(ecm.counts) == "Leccinum sp. ")] <- "Leccinum sp." 

# Get unique processed column names
unique.processed.names <- unique(names(ecm.counts))

# Initialize a new dataframe to store merged columns
ecm.counts.species.names <- data.frame(matrix(NA, nrow = nrow(ecm.counts), ncol = length(unique.processed.names)))

# Iterate over unique processed column names
for (i in seq_along(unique.processed.names)) {
  # Get the current unique processed column name
  current.name <- unique.processed.names[i]
  
  # Find all column names matching the current unique processed column name
  matching.names <- grep(paste0("^", current.name), names(ecm.counts), value = TRUE)
  
  # Check the number of matching columns
  num.matching <- length(matching.names)
  
  # If there's only one matching column, copy its values directly to the merged dataframe
  if (num.matching == 1) {
    ecm.counts.species.names[, i] <- ecm.counts[, matching.names, drop = FALSE]
  } else {
    # Sum the matching columns and store the result in the merged dataframe
    ecm.counts.species.names[, i] <- rowSums(ecm.counts[, matching.names, drop = FALSE])
  }
}

# Rename the columns of the merged dataframe
colnames(ecm.counts.species.names) <- unique.processed.names
ecm.counts.species.names$Sample <- ecm.sample.total.df$Sample
```

aggregating at genus

```{r}
species.names <- colnames(ecm.counts.species.names)
genera.O <- str_split(species.names, pattern = " ", simplify = TRUE)[,1]
genera.O[genera.O == "Cortinarius mucosus/alpinus/fennoscandicus/trivialis"] <- "Cortinarius" 
print(genera.O)

ecm.genera.counts <- ecm.counts.species.names
colnames(ecm.genera.counts) <- genera.O

# Get unique processed column names
unique.genera.names <- unique(names(ecm.genera.counts))

# Initialize a new dataframe to store merged columns
ecm.genera.counts.aggregated <- data.frame(matrix(NA, nrow = nrow(ecm.genera.counts), ncol = length(unique.genera.names)))

# Iterate over unique processed column names
for (i in seq_along(unique.genera.names)) {
  # Get the current unique processed column name
  current.name <- unique.genera.names[i]
  
  # Find all column names matching the current unique processed column name
  matching.names <- grep(paste0("^", current.name), names(ecm.genera.counts), value = TRUE)
  
  # Check the number of matching columns
  num.matching <- length(matching.names)
  
  # If there's only one matching column, copy its values directly to the merged dataframe
  if (num.matching == 1) {
    ecm.genera.counts.aggregated[, i] <- ecm.genera.counts[, matching.names, drop = FALSE]
  } else {
    # Sum the matching columns and store the result in the merged dataframe
    ecm.genera.counts.aggregated[, i] <- rowSums(ecm.genera.counts[, matching.names, drop = FALSE])
  }
}

colnames(ecm.genera.counts.aggregated) <- unique.genera.names

genera.total.counts.O <- colSums(ecm.genera.counts.aggregated[, -c(27,28)])
genera.total.counts.O <- as.data.frame(genera.total.counts.O)
sum.genera <- sum(genera.total.counts.O$genera.total.counts.O)

rel.abund.genera.O<-(genera.total.counts.O$genera.total.counts.O / sum.genera)*100

genera.total.counts.O$rel.abund.genera.O <- rel.abund.genera.O

Genera <- rownames(genera.total.counts.O)

#par(mfrow=c(2,1))

library(gridExtra)
pie.olayer <- ggplot(genera.total.counts.O, aes(x = "", y = rel.abund.genera.O, fill = Genera, linetype = "solid")) +
  geom_bar(stat = "identity", width = 1, color = "black") +
  coord_polar(theta = "y", start = 0) +  # Transform to polar coordinates for pie chart
  theme_minimal() +
  labs(title = "Genus Abundance for Organic Layer")

#pie.mineral <- ggplot(genera.total.counts, aes(x = "", y = rel.abund.genera, fill = Genera.mineral, linetype = "solid")) +
# geom_bar(stat = "identity", width = 1, color = "black") +
# coord_polar(theta = "y", start = 0) +  # Transform to polar coordinates for pie chart
# theme_minimal() +
# labs(title = "Genus Abundance for Mineral Soil", fill = "Genus")+
# scale_y_continuous(labels = NULL) +  # Remove y-axis labels
# theme(axis.title.x = element_blank())  # Remove legend

#grid.arrange(pie.olayer, pie.mineral, ncol = 2) 

```

```{r pressure, echo=FALSE}

ecm.species.sample.total <- rowSums(ecm.counts.species.names[,-c(76)])

ecm.rel.abund <- ecm.counts.species.names[,-c(76)] / ecm.species.sample.total
ecm.rel.abund$Sample <- ecm.counts.species.names[,76]
ecm.rel.abund$Treatment <- ECM.proportion.sample.df$Treatment

```

Aggregating by treatment group

```{r pressure, echo=FALSE}
collapsed.ecm.counts.species.names.filtered <- ecm.counts.species.names.filtered %>%
  group_by(Treatment) %>%
  summarise(across(-Sample, sum))

sample.totals.ecm.collapsed  <- rowSums(collapsed.ecm.counts.species.names.filtered[,-1])

#datatreatment <- collapsed_df[,-1] / sample_totals
#rowSums(datatreatment[,-77])
#datatreatment$Treatment <- collapsed_df$Treatment

#retained.30 <- colMeans(ecm.rel.abund[ecm.rel.abund$Sample %in% c("S1", "S20", "S4", "S8"), -c(76,77)]) 
#retained.60 <- colMeans(ecm.rel.abund[ecm.rel.abund$Sample %in% c("S12",  "S19", "S3"),-c(76,77)])
#clearcut <- colMeans(ecm.rel.abund[ecm.rel.abund$Sample %in% c("S14", "S5", "S9"),-c(76,77)])
#control <- colMeans(ecm.rel.abund[ecm.rel.abund$Sample %in% c("S10", "S13", "S17", "S6", "S7"),-c(76,77)])

#retained.30 <- data.frame(retained.30)
#retained.60 <- data.frame(retained.60)
#clearcut <- data.frame(clearcut)
#control <- data.frame(control)
#avearage.ecm.counts.treatment <- cbind(retained.30, retained.60, clearcut, control)

datatreatment <- collapsed.ecm.counts.species.names.filtered[,-1]/sample.totals.ecm.collapsed
datatreatment$Treatment <- collapsed.ecm.counts.species.names.filtered$Treatment

df.long <- tidyr::gather(datatreatment, key = "Taxa", value = "Value", -Treatment) #Usally -Treatment

ggplot(df.long, aes(x = Treatment, y = Value, fill = Taxa)) +
  geom_bar(stat = "identity") +
  labs(title = "Stacked Barplot of Taxa by Treatment",
       x = "Treatment",
       y = "Relative Abundance") +
  theme_minimal() +
  theme(legend.position = "right")
```

Creating an NMDS to show sample differences

```{r pressure, echo=FALSE}
# Install and load the vegan package

library(vegan)

#Only go forward with samples that are present in 2 samples or more
#ecm.rel.abund.filtered <- ecm.rel.abund[, colSums(ecm.rel.abund != 0) > 2]

##NMDS
dissimilarity.matrix <- vegdist(ecm.rel.abund[,-c(76,77)], method = "bray") #remove sample and treatment row?
# Set k to the number of dimensions you want (e.g., 2)
nmds.result <- metaMDS(dissimilarity.matrix, k = 2)  

ecm.rel.abund$treedensity <- metadata$Density

# Create an empty plot for NMDS
plot(nmds.result)
text(nmds.result$points, labels = ecm.rel.abund$treedensity, cex = 0.7, pos = 2) 

# Add labels to the points
#text(nmds.result$points, labels = ecm.rel.abund$Treatment, cex = 0.7, pos = 4)
```

MVABUND to identify species changes between treatment groups

```{r pressure, echo=FALSE}
#install.packages("mvabund")
library(mvabund)

ecm.relanund.mvabund <- (ecm.rel.abund[, -c(76,77,78)])*1000
ecm.relanund.mvabund <- round(ecm.relanund.mvabund)
#datamvabund$Treatment <- filtered_df$Treatment

ECM.spp.mvabund <- mvabund(ecm.relanund.mvabund)

#meanvar.plot(ECM.spp.mvabund)
#plot(ECM.spp.mvabund ~ as.factor(ecm.rel.abund$Treatment), cex.axis = 0.8, cex = 0.8)

ECM.manyglm <- manyglm(ECM.spp.mvabund ~ ecm.rel.abund$Treatment, family = "negative_binomial")

plot(ECM.manyglm) 

anova(ECM.manyglm)

anova(ECM.manyglm, p.uni = "adjusted")
```

Stratified permanova for mineral soil
```{r pressure, echo=FALSE}
anova.manyglm(ECM.manyglm)

summary.manyglm(ECM.manyglm)

library(vegan)

mineral.ecm.rel.abund #update names to add mineral to differentiate
#need to be able to merge by column so that columns line up?
ecm.rel.abund

# Calculate dissimilarity matrix
dissimilarity_matrix <- vegdist(data[, -c(1:2)], method = "bray")

# Stratified PERMANOVA
results <- adonis2(dissimilarity_matrix ~ SoilType, data = data, strata = data$PlotID)
print(results) 
```
